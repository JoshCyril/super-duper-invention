import streamlit as st
import networkx as nx
from pyvis.network import Network
import streamlit.components.v1 as components
import yaml  # Added for YAML loading
import os    # Added to handle file paths

# --- APP CONFIGURATION ---
st.set_page_config(
    page_title="Interactive Graph Creator ðŸ•¸ï¸",
    page_icon="ðŸ•¸ï¸",
    layout="wide",
    initial_sidebar_state="expanded"
)

# --- HELPER FUNCTION TO LOAD DATA FROM YAML ---
def load_graph_data(filepath):
    """Loads node and edge data from a YAML file."""
    try:
        with open(filepath, 'r', encoding='utf-8') as file:
            return yaml.safe_load(file)
    except FileNotFoundError:
        st.error(f"Error: The file '{filepath}' was not found. Please make sure it exists.")
        return None
    except yaml.YAMLError as e:
        st.error(f"Error parsing YAML file: {e}")
        return None


# --- INITIALIZE SESSION STATE ---
def initialize_session_state():
    """Initializes the session state for the graph by loading from YAML."""
    if 'graph' not in st.session_state:
        st.session_state.graph = nx.Graph()
        
        # Load data from the YAML file
        data = load_graph_data('data.yml')
        
        if data and 'nodes' in data:
            for node in data['nodes']:
                st.session_state.graph.add_node(
                    node['id'], 
                    title=node.get('title', ''), 
                    color=node.get('color', '#FFFFFF')
                )
        
        if data and 'edges' in data:
            edges = [(edge['source'], edge['target']) for edge in data['edges']]
            st.session_state.graph.add_edges_from(edges)

initialize_session_state()


# --- SIDEBAR FOR CONTROLS ---
st.sidebar.title("Graph Controls")
st.sidebar.markdown("Manage the nodes and edges of your graph.")

# --- Helper function to reset graph
def reset_graph():
    """Clears the graph and re-initializes from the YAML file."""
    st.session_state.clear()
    initialize_session_state()
    st.success("Graph has been reset from the data.yml file!")


# --- Add Node Form ---
with st.sidebar.form("add_node_form"):
    st.subheader("Add a New Node")
    node_name = st.text_input("Node Name / ID", key="node_name_input")
    node_content = st.text_area(
        "Node Content (Markdown)",
        height=150,
        placeholder="Enter details here...\nSupports **Markdown**!",
        key="node_content_input"
    )
    node_color = st.color_picker("Node Color", "#FFFFFF")
    add_node_button = st.form_submit_button("Add Node")

    if add_node_button and node_name:
        if st.session_state.graph.has_node(node_name):
            st.warning(f"Node '{node_name}' already exists.")
        else:
            st.session_state.graph.add_node(node_name, title=node_content, color=node_color)
            st.success(f"Node '{node_name}' added successfully.")
            st.rerun()


# --- Add Edge Form ---
if len(st.session_state.graph.nodes) > 1:
    with st.sidebar.form("add_edge_form"):
        st.subheader("Add a New Edge")
        nodes = list(st.session_state.graph.nodes)
        source_node = st.selectbox("Source Node", options=nodes, index=0)
        target_node = st.selectbox("Target Node", options=nodes, index=1 if len(nodes) > 1 else 0)
        add_edge_button = st.form_submit_button("Add Edge")

        if add_edge_button:
            if source_node == target_node:
                st.warning("Source and target nodes cannot be the same.")
            elif st.session_state.graph.has_edge(source_node, target_node):
                st.warning(f"An edge between '{source_node}' and '{target_node}' already exists.")
            else:
                st.session_state.graph.add_edge(source_node, target_node)
                st.success(f"Edge added between '{source_node}' and '{target_node}'.")
                st.rerun()

# --- Node Inspector ---
st.sidebar.divider()
st.sidebar.subheader("Inspect a Node")
if st.session_state.graph.nodes:
    # Sort nodes for easier selection
    sorted_nodes = sorted(list(st.session_state.graph.nodes))
    selected_node = st.sidebar.selectbox(
        "Select a node to view its content:",
        options=[""] + sorted_nodes
    )
    if selected_node:
        node_data = st.session_state.graph.nodes[selected_node]
        st.sidebar.markdown(node_data.get('title', "No content available for this node."))
else:
    st.sidebar.info("The graph is empty. Add some nodes to get started.")

# --- Reset Button ---
st.sidebar.divider()
if st.sidebar.button("Reset Graph", type="primary", use_container_width=True):
    reset_graph()
    st.rerun()


# --- MAIN PANEL FOR VISUALIZATION ---
st.title("Interactive Graph Visualizer")
st.markdown(
    "Use the controls in the sidebar to build your graph. Hover over nodes for a quick look, or use the 'Inspect a Node' dropdown for full details."
)

# Create a PyVis network object
net = Network(height="700px", width="100%", bgcolor="#222222", font_color="white", notebook=True, cdn_resources='in_line')

# Add nodes and edges from the session state graph to the PyVis network
net.from_nx(st.session_state.graph)

# Add physics-based layout options
net.set_options("""
var options = {
  "nodes": { "font": { "size": 16 } },
  "edges": { "color": { "inherit": true }, "smooth": { "type": "continuous" } },
  "interaction": { "navigationButtons": true, "keyboard": { "enabled": true } },
  "physics": { "barnesHut": { "gravitationalConstant": -30000, "centralGravity": 0.3, "springLength": 150, "springConstant": 0.05 } }
}
""")

# --- RENDER THE GRAPH ---
try:
    # CORRECTED: Use save_as_html to generate the interactive web page
    graph_html_file = "interactive_graph.html"
    net.save_as_html(graph_html_file)

    # Read the generated HTML file
    with open(graph_html_file, "r", encoding="utf-8") as f:
        html_code = f.read()

    # Display the HTML in the Streamlit app
    components.html(html_code, height=715)

except Exception as e:
    st.error(f"An error occurred while rendering the graph: {e}")


----
nodes:
  - id: "Data Ingestion"
    title: |
      # Data Ingestion
      
      **Description:** This node represents the process of collecting and importing raw data from various sources.
      
      - **Source:** APIs, Databases
      - **Output:** Raw data files (e.g., CSV, JSON)
    color: "#FFC0CB" # Light Pink

  - id: "Data Cleaning"
    title: |
      # Data Cleaning
      
      **Description:** Cleans and preprocesses raw data to handle missing values, outliers, and inconsistencies.
      
      - **Tasks:** Imputation, Normalization
      - **Depends on:** Data Ingestion
    color: "#ADD8E6" # Light Blue

  - id: "Feature Engineering"
    title: |
      # Feature Engineering
      
      **Description:** Creates meaningful features from the cleaned data to be used for model training.
      
      - **Techniques:** One-hot encoding, PCA
      - **Depends on:** Data Cleaning
    color: "#90EE90" # Light Green
      
  - id: "Model Training"
    title: |
      # Model Training
      
      **Description:** Trains a machine learning model on the engineered features.
      
      - **Models:** Logistic Regression, Random Forest
      - **Depends on:** Feature Engineering
    color: "#FFDAB9" # Peach

  - id: "API Deployment"
    title: |
      # API Deployment
      
      **Description:** Deploys the trained model as a REST API for predictions.
      
      - **Framework:** Flask, FastAPI
      - **Depends on:** Model Training
    color: "#E6E6FA" # Lavender

edges:
  - source: "Data Ingestion"
    target: "Data Cleaning"
  - source: "Data Cleaning"
    target: "Feature Engineering"
  - source: "Feature Engineering"
    target: "Model Training"
  - source: "Model Training"
    target: "API Deployment"

